Elm.GameLogic = Elm.GameLogic || {};
Elm.GameLogic.make = function (_elm) {
   "use strict";
   _elm.GameLogic = _elm.GameLogic || {};
   if (_elm.GameLogic.values) return _elm.GameLogic.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Graph = Elm.Graph.make(_elm),
   $Helpers = Elm.Helpers.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm);
   var _op = {};
   var performEntireCollapse = function (field) {    var _p0 = field;var nodes = _p0._0;var edges = _p0._1;return field;};
   var replaceNode = F3(function (field,node,p) {
      var l = node.label;
      var newNumberOfMove = $Helpers.unsafe($List.maximum(A2($List.map,
      function (x) {
         return x.label.numberOfMove;
      },
      A2($List.filter,function (x) {    return _U.eq(x.label.player,$Helpers.unsafe(node.label.player));},A2($Graph.incidentEdges,field,node)))));
      var newLabel = _U.update(l,{numberOfMove: newNumberOfMove,player: $Maybe.Just(p)});
      var newNode = _U.update(node,{label: newLabel});
      var _p1 = field;
      var nodes = _p1._0;
      var edges = _p1._1;
      return {ctor: "_Tuple2",_0: A2($Graph.updateNode,newNode,nodes),_1: edges};
   });
   var collapseOneEdge = F2(function (field,edge) {
      var edgePlayer = edge.label.player;
      var secondNode = $Helpers.unsafe(A2($Graph.getNodeFromId,field,edge.second));
      var firstNode = $Helpers.unsafe(A2($Graph.getNodeFromId,field,edge.first));
      var _p2 = field;
      var nodes = _p2._0;
      var edges = _p2._1;
      var _p3 = firstNode.label.player;
      if (_p3.ctor === "Nothing") {
            var _p4 = secondNode.label.player;
            if (_p4.ctor === "Nothing") {
                  return field;
               } else {
                  return _U.eq(_p4._0,edgePlayer) ? A2($Graph.removeEdge,field,edge) : A2($Graph.removeEdge,A3(replaceNode,field,firstNode,edgePlayer),edge);
               }
         } else {
            return _U.eq(_p3._0,edgePlayer) ? A2($Graph.removeEdge,field,edge) : A2($Graph.removeEdge,A3(replaceNode,field,secondNode,edgePlayer),edge);
         }
   });
   var isCollapseNecessary = function (field) {    return $Helpers.isJust($Graph.findComponentWithCycle(field));};
   var isEdgeOnField = F2(function (edge,field) {
      var condition = function (x) {
         return (_U.eq(x.first,edge.first) && _U.eq(x.second,edge.second) || _U.eq(x.first,edge.second) && _U.eq(x.second,
         edge.first)) && _U.eq(edge.label.player,x.label.player);
      };
      var _p5 = field;
      var nodes = _p5._0;
      var edges = _p5._1;
      return $Basics.not($List.isEmpty(A2($List.filter,condition,edges)));
   });
   var fieldNumbers = A2($Helpers.tuples,_U.range(1,3),_U.range(1,3));
   var nodeConstr = function (_p6) {
      var _p7 = _p6;
      return {id: _p7._0,label: {pos: {col: _p7._1._0,row: _p7._1._1},numberOfMove: -1,player: $Maybe.Nothing}};
   };
   var nodes = A2($List.map,nodeConstr,A2($Helpers.zip,_U.range(1,9),fieldNumbers));
   var emptyField = {ctor: "_Tuple2",_0: nodes,_1: _U.list([])};
   var returnMoves = function (state) {    var _p8 = state;if (_p8.ctor === "FinishedGame") {    return _p8._2;} else {    return _p8._2;}};
   var returnPlayer = function (state) {
      var _p9 = state;
      if (_p9.ctor === "FinishedGame") {
            return $Maybe.Nothing;
         } else {
            return $Maybe.Just(_p9._0);
         }
   };
   var returnRound = function (state) {    var _p10 = state;if (_p10.ctor === "FinishedGame") {    return 0;} else {    return _p10._3;}};
   var returnField = function (state) {    var _p11 = state;if (_p11.ctor === "FinishedGame") {    return _p11._1;} else {    return _p11._1;}};
   var isValidMove = F2(function (move,state) {
      var field = returnField(state);
      var _p12 = field;
      var nodes = _p12._0;
      var edges = _p12._1;
      var _p13 = move;
      if (_p13.ctor === "Entangled") {
            return isCollapseNecessary(field) ? false : $Basics.not(A2(isEdgeOnField,_p13._0,field));
         } else {
            var _p14 = _p13._0;
            if (isCollapseNecessary(field)) {
                  var edgesIncidentToNode = A2($Graph.incidentEdges,field,_p14);
                  var componentWithCycle = $Helpers.unsafe($Graph.findComponentWithCycle(field));
                  return A2($List.member,_p14.id,A2($List.map,function (_) {    return _.id;},componentWithCycle)) && A2($List.member,
                  $Helpers.unsafe(_p14.label.player),
                  A2($List.map,function (y) {    return y.label.player;},edgesIncidentToNode)) ? true : false;
               } else return false;
         }
   });
   var NotFinishedGame = F4(function (a,b,c,d) {    return {ctor: "NotFinishedGame",_0: a,_1: b,_2: c,_3: d};});
   var FinishedGame = F3(function (a,b,c) {    return {ctor: "FinishedGame",_0: a,_1: b,_2: c};});
   var checkIfFinished = function (state) {
      var _p15 = state;
      if (_p15.ctor === "FinishedGame") {
            return A3(FinishedGame,_p15._0,_p15._1,_p15._2);
         } else {
            return A4(NotFinishedGame,_p15._0,_p15._1,_p15._2,_p15._3);
         }
   };
   var Collapse = function (a) {    return {ctor: "Collapse",_0: a};};
   var Entangled = function (a) {    return {ctor: "Entangled",_0: a};};
   var EdgeLabel = F2(function (a,b) {    return {numberOfMove: a,player: b};});
   var NodeLabel = F3(function (a,b,c) {    return {pos: a,numberOfMove: b,player: c};});
   var Position = F2(function (a,b) {    return {col: a,row: b};});
   var Winner = function (a) {    return {ctor: "Winner",_0: a};};
   var Tie = function (a) {    return {ctor: "Tie",_0: a};};
   var Draw = {ctor: "Draw"};
   var X = {ctor: "X"};
   var initialState = A4(NotFinishedGame,X,emptyField,_U.list([]),0);
   var O = {ctor: "O"};
   var switchPlayer = function (p) {    var _p16 = p;if (_p16.ctor === "X") {    return O;} else {    return X;}};
   var addMove = F2(function (move,state) {
      var field = returnField(state);
      var _p17 = field;
      var nodes = _p17._0;
      var edges = _p17._1;
      return A2(isValidMove,move,state) ? checkIfFinished(function () {
         var _p18 = move;
         if (_p18.ctor === "Entangled") {
               return A4(NotFinishedGame,
               switchPlayer($Helpers.unsafe(returnPlayer(state))),
               {ctor: "_Tuple2"
               ,_0: nodes
               ,_1: A2($List._op["::"],_U.update(_p18._0,{label: {numberOfMove: returnRound(state),player: $Helpers.unsafe(returnPlayer(state))}}),edges)},
               A2($List._op["::"],move,returnMoves(state)),
               returnRound(state) + 1);
            } else {
               var _p19 = _p18._0;
               return A4(NotFinishedGame,
               $Helpers.unsafe(returnPlayer(state)),
               performEntireCollapse(A3(replaceNode,field,_p19,$Helpers.unsafe(_p19.label.player))),
               A2($List._op["::"],move,returnMoves(state)),
               returnRound(state));
            }
      }()) : state;
   });
   return _elm.GameLogic.values = {_op: _op
                                  ,O: O
                                  ,X: X
                                  ,Draw: Draw
                                  ,Tie: Tie
                                  ,Winner: Winner
                                  ,Position: Position
                                  ,NodeLabel: NodeLabel
                                  ,EdgeLabel: EdgeLabel
                                  ,Entangled: Entangled
                                  ,Collapse: Collapse
                                  ,FinishedGame: FinishedGame
                                  ,NotFinishedGame: NotFinishedGame
                                  ,returnField: returnField
                                  ,returnRound: returnRound
                                  ,returnPlayer: returnPlayer
                                  ,returnMoves: returnMoves
                                  ,switchPlayer: switchPlayer
                                  ,nodeConstr: nodeConstr
                                  ,fieldNumbers: fieldNumbers
                                  ,nodes: nodes
                                  ,emptyField: emptyField
                                  ,initialState: initialState
                                  ,isEdgeOnField: isEdgeOnField
                                  ,isValidMove: isValidMove
                                  ,isCollapseNecessary: isCollapseNecessary
                                  ,addMove: addMove
                                  ,replaceNode: replaceNode
                                  ,checkIfFinished: checkIfFinished
                                  ,performEntireCollapse: performEntireCollapse
                                  ,collapseOneEdge: collapseOneEdge};
};